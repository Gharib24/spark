#!/usr/bin/env python
import os

import gi

gi.require_version('Gtk', '3.0')
from gi.repository import Gtk, GObject


class WidgetsFieldValue:
	def __init__(self):
		self.value_dict = {}
		super().__init__()

	def get_value_from_preseed_file(self):
		self.value_dict.clear()
		with open(self.settings.PRESEED_FILE, "r") as f:
			first_line = f.readline().replace('\n', '')
			f.close
		if first_line == '# generated by spark *':
			with open(self.settings.PRESEED_FILE, "r") as f:
				for line in f:
					if '#' in line  or not line.strip():
						continue
					else:
						thislist = (line.strip().split())
						if len(thislist) >= 1:
							question = thislist[1]
							if len(thislist) >= 4:
								value = ' '.join((line.strip(' ').split()[3:]))
								self.value_dict[question] = value
							elif len(thislist) == 3:
								self.value_dict[question] = " "
				f.close
		if len(self.value_dict) > 0:
			return True
		else:

			return False

#-------------------------------------------------------------------------------

	def return_widgets_field_value(self):
		for index, (question, value) in enumerate(self.value_dict.items()):
			if question in self.question_to_own_widget_object_dict.keys():
				widget_obj = self.question_to_own_widget_object_dict.get(question)
				widget_type_name = GObject.type_name(widget_obj).replace('Gtk', "").lower()
				if hasattr(self, f"return_{widget_type_name}_value"):
					value = self.value_dict.get(question)
					handler = getattr(self, f"return_{widget_type_name}_value")
					handler(widget_obj, question, value)
				else:
					self.log.warn(f"return_{widget_type_name}_value does not exist")
			elif question == 'apt-setup/services-select':
				for i in value.split(', '):
					if i == 'security':
						widget_obj = self.question_to_own_widget_object_dict.get(f'{question}0')
						self.return_checkbutton_value(widget_obj, question, 'true')
					elif i == 'updates':
						widget_obj = self.question_to_own_widget_object_dict.get(f'{question}1')
						self.return_checkbutton_value(widget_obj, question, 'true')
					elif i == 'volatile':
						widget_obj = self.question_to_own_widget_object_dict.get(f'{question}2')
						self.return_checkbutton_value(widget_obj, question, 'true')

			elif question == 'entry_netcfg_wireless_wap':
					widget_obj = self.question_to_own_widget_object_dict.get('entry_netcfg_wireless_wep')
					self.return_entry_value(widget_obj,question, value)

#-------------------------------------------------------------------------------

	def return_liststore_value(self, widget_obj,question, value):
		model = self.question_to_own_widget_object_dict.get(question)
		if question == 'partman-auto/expert_recipe':
			disk = self.widgets_object_dict.get('comboboxtext_partman_auto_disk').get_active_id()
			if disk == None:
				self.widgets_object_dict.get('comboboxtext_partman_auto_disk').set_active(0)
				disk = self.widgets_object_dict.get('comboboxtext_partman_auto_disk').get_active_id()
			first_cell_text = disk
			thislist = value.split()
			thislist.pop(0)
			thislist.pop(0)
			thislist = ' '.join(thislist)
			thislist = thislist.split('.')
			thislist.pop()
			newlist = []
			for counter, item in enumerate(thislist):
				newlist.append({})
				newlist[counter]["partition"] = first_cell_text+str(counter+1)
				templist = item.split()
				for i, text in enumerate(templist):
					if i == 0:
						newlist[counter]["min_size"] = text
					elif i == 1:
						newlist[counter]["priority_size"] = text
					elif i == 2:
						newlist[counter]["max_size"] = text
					elif i == 3:
						newlist[counter]["filesystem"] = text
					elif text == 'mountpoint{':
						index = templist.index(text)+1
						newlist[counter]["mountpoint"] = templist[index]
					elif text == 'label{':
						index = templist.index(text)+1
						newlist[counter]["label"] = templist[index]
					if 'label{' not in templist:
						newlist[counter]["label"] = "N/A"
					if 'mountpoint{' not in templist:
						newlist[counter]["mountpoint"] = "N/A"


			for counter, in_dict in enumerate(newlist):
				model.append(row=None)
				for path, text in enumerate(('partition', 'filesystem', 'mountpoint', 'min_size', 'priority_size', 'max_size', 'label'), 0):
					model[counter][path] = in_dict.get(text)

		elif question == 'apt-setup/local0/repository':
			thislist = []
			for i in range(0, 10):
				local ='local'+str(i)
				value = self.value_dict.get('apt-setup/'+local+'/repository')
				if value != None:
					thislist.append([])
					thislist[i].append(local)
				for text in ('repository','key', 'comment', 'source'):
					value = self.value_dict.get('apt-setup/'+local+'/'+text)
					if value != None:
						if value =='true':
							value = True
						elif value =='false':
							value = False
						thislist[i].append(value)
			if len(model) > 0:
				for i in range(len(model)):
					iter = model.get_iter(0)
					model.remove(iter)
			for i in range(len(thislist)):
				model.append(thislist[i])

		self.col_data_handler(question)

#-------------------------------------------------------------------------------

	def return_entry_value(self, widget, question, value):
		if 'crypted' in question:
			widget.set_text('PASSWORD')
			self.do_data_Handler(question, value)
		else:
			widget.set_text(value)
#
#-------------------------------------------------------------------------------

	def return_checkbutton_value(self, widget, question, value):
		if value in ['true', None]:
			value = True
		elif value =='false':
			value = False
		widget.set_active(value)
		if question in ['passwd/root-login', 'apt-setup/cdrom/set-first']:
			value = not value
#		self.log.normal(question)
			widget.set_active(value)

#-------------------------------------------------------------------------------
	def return_combobox_value(self, widget, question, value):
		model = widget.get_model()
		for path in range(len(model)):
			if model[path][0].split(' ')[0] == value:
				widget.set_active(path)
				break
#-------------------------------------------------------------------------------

	def return_comboboxtext_value(self, widget, question, value):
		if widget.get_has_entry():
			model = widget.get_model()
			for path in range(len(model)):
				if model[path][0] == value:
					in_model = True
					break
				else:
					in_model = False
			if in_model:
				widget.set_active_id(value)
			else:
				widget.insert_text(0, value)
				widget.set_active(0)
		else:
			widget.set_active_id(value)
#-------------------------------------------------------------------------------

	def return_treeview_value(self, widget, question, value):
		model = widget.get_model()
		name = self.naming(question)
		cellrenderertoggle = self.widgets_object_dict.get(f'cellrenderertoggle_0_{name}')
		thislist = value.split(', ')
		if question == 'tasksel/first':
			for path in range(len(self.tasksel_first)):
				if self.tasksel_first[path][1] in thislist:
					self.on_cellrenderertoggle_toggled(cellrenderertoggle, path)
		else:
			for path in range(len(model)):
				if model[path][1].split(' ')[0] in thislist:
					self.on_cellrenderertoggle_toggled(cellrenderertoggle, path)

##------------------------------------------------------------------------------

	def return_textview_value(self, widget, question, value):
		textbuffer = widget.get_buffer()
#		start, end = textbuffer.get_bounds()
#		textbuffer.insert(end,value)
		name = self.naming(question)
		if question in ('preseed/run', 'preseed/late_command',):
			if question == 'preseed/run':
				script = self.settings.PRE_INSTALLATION_SCRIPT
			elif question == 'preseed/late_command':
				script = self.settings.POST_INSTALLATION_SCRIPT
			if os.path.getsize(script) > 0:
				with open(script, 'r') as f:
					textbuffer.set_text(f.read())
					f.close()

			button = self.widgets_object_dict.get(f"button_0_{name}")
			self.on_button_clicked(button, dialog=None)
			button = self.widgets_object_dict.get(f"button_1_{name}")
			self.on_button_clicked(button, dialog=None)

		else:
			textbuffer.set_text(value)





















##------------------------------------------------------------------------------

